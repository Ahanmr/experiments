// Variable to store control UI
var controlkit;

/*
Variables to store type of Oscillator (Sine, Sawtooth, Triangle, None..)
To be used in draw
*/
var osc1Type;
var osc2Type;
var osc3Type;

/* 
Data related to this experiment : 
bins = number of samples
smoothing : smoothens out stuff by averaging with previous amplitudes.
Rest is understandable.
*/

var data = {
	bins: {
		options: [1024, 512, 256, 128],
		selection: null
	},
	smoothing: 0.8,
	c_1: {
		amplitude: 0.3,
		frequency: 343.53,
		phase: 0,
		function: {
			options: ["Sine", "Square", "Sawtooth", "Triangle", "None"],
			selection: null
		},
		frequency_domain: false
	},
	c_2: {
		amplitude: 0.3,
		frequency: 345.53,
		phase: 0,
		function: {
			options: ["Sine", "Square", "Sawtooth", "Triangle", "None"],
			selection: null
		},
		frequency_domain: false
	},
	c_3: {
		freeze: true,
		operation: {
			options: ["Add", "Multiply"],
			selection: null
		},
		frequency_domain: false
	}
};

// Function to create the control GUI and store it in our global variable.
// Refer to controlKit documentation to understand how this works.
var createControlKit = () => {
	controlkit = new ControlKit();
	controlkit
		.addPanel({
			align: "right",
			fixed: true
		})
		.addSelect(data["bins"], "options", {
			label: "Bins / Samples",
			onChange: function(index) {
				data["bins"].selection = data["bins"].options[index];
			}
		})
		.addNumberInput(data, "smoothing", {
			label: "Smoothing",
			step: 0.1
		})
		.addGroup({
			label: "Wave Controls"
		})
		.addSubGroup({
			label: "Input Wave #1"
		})
		.addSelect(data["c_1"]["function"], "options", {
			label: "Function",
			onChange: function(index) {
				data["c_1"]["function"].selection = data["c_1"]["function"].options[
					index
				].toLowerCase();
				osc1Type = data["c_1"]["function"].selection.toLowerCase();
			}
		})
		.addNumberInput(data["c_1"], "amplitude", {
			label: "Amplitude",
			step: 0.1
		})
		.addNumberInput(data["c_1"], "frequency", {
			label: "Frequency"
		})
		.addNumberInput(data["c_1"], "phase", {
			label: "Phase",
			step: 10
		})
		.addCheckbox(data["c_1"], "frequency_domain", {
			label: "Frequency Spectrum?",
			onChange: function() {}
		})
		.addSubGroup({
			label: "Input Wave #2"
		})
		.addSelect(data["c_2"]["function"], "options", {
			label: "Function",
			onChange: function(index) {
				data["c_2"]["function"].selection = data["c_2"]["function"].options[
					index
				].toLowerCase();
				osc2Type = data["c_2"]["function"].selection.toLowerCase();
			}
		})
		.addNumberInput(data["c_2"], "amplitude", {
			label: "Amplitude",
			step: 0.1
		})
		.addNumberInput(data["c_2"], "frequency", {
			label: "Frequency"
		})
		.addNumberInput(data["c_2"], "phase", {
			label: "Phase",
			step: 10
		})
		.addCheckbox(data["c_2"], "frequency_domain", {
			label: "Frequency Spectrum?",
			onChange: function() {}
		})
		.addSubGroup({
			label: "Output Wave"
		})
		.addSelect(data["c_3"]["operation"], "options", {
			label: "Operation",
			onChange: function(index) {
				data["c_3"]["operation"].selection =
					data["c_3"]["operation"].options[index];
			}
		})
		.addCheckbox(data["c_3"], "frequency_domain", {
			label: "Frequency Spectrum?",
			onChange: function() {}
		});
};

// Setting default values for Bins and Smoothing.
data.bins.selection = 1024;
data.smoothing = 0.8;

// Waveform and Spectrum of Wave 1 Canvas will be available to Output Canvas;
var waveform_1;
var spectrum_1;
var c_1 = s => {
	let canvas; // WIll store first canvas
	let start = false; // Purpose : To stop the oscillator when 'None' is selected.
	let osc; // Will store Oscillator for our first canvas
	let fft; // Will store FFT object, which will listen only to wave generated by Canvas 1 Oscillator

	s.setup = () => {
		// Creating Canvas and appending it to a div element with ID : 'canvas-1'
		canvas = s.createCanvas(s.windowWidth * 0.7, s.windowHeight / 3);
		$("#canvas-1").html(canvas.canvas);

		// Creating an instance of Oscillator, setting initial frequency and amplitude
		osc = new p5.Oscillator();
		osc.freq(data["c_1"]["frequency"]);
		osc.amp(data["c_1"]["amplitude"]);

		// Creating instance of FFT object and make it listen only to Canvas 1 Oscillator.
		// If at any time smoothing or bins change, fft variable will be reinstantiated.
		fft = new p5.FFT(data.smoothing, data.bins.selection);
		fft.setInput(osc);
	};

	let flag = 0; // Required to stop the oscillator in draw function
	s.draw = () => {
		// Creating background, and an X-axis.
		s.background(0);
		s.strokeCap(s.SQUARE);
		s.strokeWeight(1);
		s.stroke(255);
		s.line(s.width * 0, s.height * 0.5, s.width * 1, s.height * 0.5);

		// Logic to control when the oscillator should start or stop.
		if (
			data["c_1"]["function"]["selection"] !== null &&
			data["c_1"]["function"]["selection"] !== "none"
		) {
			start = true;
		} else {
			start = false;
			osc.stop();
			flag = 0;
		}

		// If the oscillator is running, set it's properties : Phase, Amp, Freq, Type..
		if (start) {
			if (flag == 0) {
				osc.start();
				flag++;
			}
			osc.phase(s.map(data["c_1"]["phase"], 0, 360, 0, 1));
			osc.amp(data["c_1"]["amplitude"], 0.05);
			osc.freq(data["c_1"]["frequency"]);
			osc.setType(osc1Type);
		}

		waveform_1 = fft.waveform(); // Contains time domain signal
		spectrum_1 = fft.analyze(); // Contains frequency domain signal

		// Stylings for the wave
		s.noFill();
		s.beginShape();
		s.stroke("tomato");
		s.strokeWeight(1);

		// Toggle between frequency & time domains and create whatever required.
		if (data["c_1"]["frequency_domain"]) {
			for (var i = 0; i < data.bins.selection; i++) {
				let x = s.map(i, 0, data.bins.selection, 0, s.width);
				let h =
					-s.height +
					s.map(spectrum_1[i], 0, 255, s.height * 0.95, s.height * 0.45);
				s.rect(x, s.height, s.width / data.bins.selection, h);
			}
		} else {
			for (var i = 0; i < data.bins.selection; i++) {
				let x = s.map(i, 0, data.bins.selection, 0, s.width);
				let y = s.map(waveform_1[i], -1, 1, 0, s.height);
				s.vertex(x, y);
			}
		}
		s.endShape();
	};

	s.windowResized = () => {
		s.resizeCanvas(s.windowWidth * 0.7, s.windowHeight / 3);
	};
};

// Waveform and Spectrum of Wave 2 Canvas will be available to Output Canvas;
var waveform_2;
var spectrum_2;
var c_2 = s => {
	let canvas; // WIll store first canvas
	let start = false; // Purpose : To stop the oscillator when 'None' is selected.
	let osc; // Will store Oscillator for our first canvas
	let fft; // Will store FFT object, which will listen only to wave generated by Canvas 2 Oscillator

	s.setup = () => {
		// Creating Canvas and appending it to a div element with ID : 'canvas-2'
		canvas = s.createCanvas(s.windowWidth * 0.7, s.windowHeight / 3);
		$("#canvas-2").html(canvas.canvas);

		// Creating an instance of Oscillator, setting initial frequency and amplitude
		osc = new p5.Oscillator();
		osc.freq(data["c_2"]["frequency"]);
		osc.amp(data["c_2"]["amplitude"]);

		// Creating instance of FFT object and make it listen only to Canvas 2 Oscillator.
		// If at any time smoothing or bins change, fft variable will be reinstantiated.
		fft = new p5.FFT(data.smoothing, data.bins.selection);
		fft.setInput(osc);
	};

	let flag = 0; // Required to stop the oscillator in draw function
	s.draw = () => {
		// Creating background, and an X-axis.
		s.background(0);
		s.strokeCap(s.SQUARE);
		s.strokeWeight(1);
		s.stroke(255);
		s.line(s.width * 0, s.height * 0.5, s.width * 1, s.height * 0.5);

		// Logic to control when the oscillator should start or stop.
		if (
			data["c_2"]["function"]["selection"] !== null &&
			data["c_2"]["function"]["selection"] !== "none"
		) {
			start = true;
		} else {
			start = false;
			osc.stop();
			flag = 0;
		}

		// If the oscillator is running, set it's properties : Phase, Amp, Freq, Type..
		if (start) {
			if (flag == 0) {
				osc.start();
				flag++;
			}
			osc.amp(data["c_2"]["amplitude"], 0.05);
			osc.freq(data["c_2"]["frequency"]);
			osc.phase(s.map(data["c_2"]["phase"], 0, 360, 0, 1));
			osc.setType(osc2Type);
		}

		waveform_2 = fft.waveform(); // Contains time domain signal
		spectrum_2 = fft.analyze(); // Contains frequency domain signal

		// Stylings for the wave
		s.noFill();
		s.beginShape();
		s.stroke("#FF2F00");
		s.strokeWeight(1);

		// Toggle between frequency & time domains and create whatever required.
		if (data["c_2"]["frequency_domain"]) {
			for (var i = 0; i < data.bins.selection; i++) {
				let x = s.map(i, 0, data.bins.selection, 0, s.width);
				let h =
					-s.height +
					s.map(spectrum_2[i], 0, 255, s.height * 0.95, s.height * 0.45);
				s.rect(x, s.height, s.width / data.bins.selection, h);
			}
		} else {
			for (var i = 0; i < data.bins.selection; i++) {
				let x = s.map(i, 0, data.bins.selection, 0, s.width);
				let y = s.map(waveform_2[i], -1, 1, 0, s.height);
				s.vertex(x, y);
			}
		}
		s.endShape();
	};

	s.windowResized = () => {
		s.resizeCanvas(s.windowWidth * 0.7, s.windowHeight / 3);
	};
};

var c_3 = s => {
	let canvas; // WIll store Canvas 3
	let fft; // Will store FFT object which will listen to BOTH sounds, from : Canvas 1 & Canvas 2 (meaning : already adding it)
	let waveform_3; // Will store time domain output
	let spectrum_3; // Will store frequency domain output
	s.setup = () => {
		// Creating and appending Canvas to a div with ID : 'canvas-3'
		canvas = s.createCanvas(s.windowWidth * 0.7, s.windowHeight / 3);
		$("#canvas-3").html(canvas.canvas);

		// Instantiating FFT object, everytime smoothing or bins change.
		fft = new p5.FFT(data.smoothing, data.bins.selection);
	};

	s.draw = () => {
		// Creating background, and an X-axis.
		s.background(0);
		s.strokeCap(s.SQUARE);
		s.strokeWeight(1);
		s.stroke(255);
		s.line(s.width * 0, s.height * 0.5, s.width * 1, s.height * 0.5);

		/* 
		By default or when 'Add' is selected as Operation, do addition
		Otherwise do multiplication
		*/
		switch (data["c_3"]["operation"].selection) {
			case "Multiply":
				/* 
				Initializing spectrum_3 with 2048 zeroes, for Bins = 512, 256, 128.
				Calculating multiplication for 1024 bins becomes super slow, this needs to be fixed sometime later.
				For now we'll not show frequency response for multiplication of two waves if Samples / Bins = 1024.
				*/
				if (data.bins.selection < 1024) {
					for (
						var i = 0, upperLimit = data.bins.selection * 2;
						i < upperLimit;
						i += 1
					) {
						spectrum_3[i] = 0;
					}
				}

				/* 
				Iterating with limits 0 inclusive to 1024 exclusive.
				Time domain signal calculation is straight forward multiplication.
				When two waves are multiplied, they create two waves with amplitudes AB/2 and at frequencies (a + b) and (a - b)
				*/

				for (
					var i = 0, upperLimit = data.bins.selection;
					i < upperLimit;
					i += 1
				) {
					waveform_3[i] = waveform_1[i] * 1.5 * (waveform_2[i] * 1.5);
					if (data.bins.selection < 1024) {
						for (
							var j = 0, upperLimit = data.bins.selection * 2;
							j < upperLimit;
							j += 1
						) {
							if (i >= j) {
								spectrum_3[i + j] += s.map(
									spectrum_1[i] * spectrum_2[j] / 2,
									0,
									255 * 255 / 2,
									0,
									255
								);
								spectrum_3[i - j] += s.map(
									spectrum_1[i] * spectrum_2[j] / 2,
									0,
									255 * 255 / 2,
									0,
									255
								);
							}
						}
					}
				}
				break;
			case "Add":
			default:
				/*
				In case of addition, I could've used a for loop to add individual amplitudes and then create the wave later.
				But that's a poor of solving this problem. 
				Since I already had an FFT object available to me, listening to oscillators of both Canvas 1 and 2. The actual thing that it..
				listens to is the addition of those two waveforms. So I just need to get time-domain and frequency-domain signals.
				*/
				waveform_3 = fft.waveform();
				spectrum_3 = fft.analyze();
				break;
		}

		// Stylings for the wave
		s.noFill();
		s.beginShape();
		s.stroke(0, 255, 0);
		s.strokeWeight(1);

		// Toggling between time and frequency domains, drawing out shape.
		if (data["c_3"]["frequency_domain"]) {
			for (var i = 0; i < data.bins.selection; i++) {
				if (data["c_3"]["operation"].selection == "Multiply") {
					let x = s.map(i, 0, data.bins.selection, 0, s.width);
					let h =
						-s.height +
						s.map(spectrum_3[i], 0, 255, s.height * 0.95, s.height * 0.45);
					s.rect(x, s.height, s.width / data.bins.selection, h);
				} else {
					let x = s.map(i, 0, data.bins.selection, 0, s.width);
					let h =
						-s.height +
						s.map(spectrum_3[i], 0, 255, s.height * 0.95, s.height * 0.45);
					s.rect(x, s.height, s.width / data.bins.selection, h);
				}
			}
		} else {
			for (var i = 0; i < data.bins.selection; i++) {
				let x = s.map(i, 0, data.bins.selection, 0, s.width);
				let y = s.map(waveform_3[i] * 1.5, -1, 1, 0, s.height);
				s.vertex(x, y);
			}
		}

		s.endShape();
	};
	s.windowResized = () => {
		s.resizeCanvas(s.windowWidth * 0.7, s.windowHeight / 3);
	};
};

createControlKit();

// Passing down c_1, c_2, c_3 to a new p5 instance, to use P5 in instance mode.
var canvas_1 = new p5(c_1); 
var canvas_2 = new p5(c_2);
var canvas_3 = new p5(c_3);
